{"version":3,"file":"signed-xml.js","sourceRoot":"","sources":["../src/signed-xml.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  CanonicalizationAlgorithmType,\n  CanonicalizationOrTransformationAlgorithm,\n  ComputeSignatureOptions,\n  GetKeyInfoContentArgs,\n  HashAlgorithm,\n  HashAlgorithmType,\n  Reference,\n  SignatureAlgorithm,\n  SignatureAlgorithmType,\n  SignedXmlOptions,\n  CanonicalizationOrTransformAlgorithmType,\n  ErrorFirstCallback,\n  CanonicalizationOrTransformationAlgorithmProcessOptions,\n} from \"./types\";\n\nimport * as xpath from \"xpath\";\nimport * as xmldom from \"@xmldom/xmldom\";\nimport * as utils from \"./utils\";\nimport * as c14n from \"./c14n-canonicalization\";\nimport * as execC14n from \"./exclusive-canonicalization\";\nimport * as envelopedSignatures from \"./enveloped-signature\";\nimport * as hashAlgorithms from \"./hash-algorithms\";\nimport * as signatureAlgorithms from \"./signature-algorithms\";\nimport * as crypto from \"crypto\";\n\nexport class SignedXml {\n  idMode?: \"wssecurity\";\n  idAttributes: string[];\n  /**\n   * A {@link Buffer} or pem encoded {@link String} containing your private key\n   */\n  privateKey?: crypto.KeyLike;\n  publicCert?: crypto.KeyLike;\n  /**\n   * One of the supported signature algorithms. See {@link SignatureAlgorithmType}\n   */\n  signatureAlgorithm: SignatureAlgorithmType = \"http://www.w3.org/2000/09/xmldsig#rsa-sha1\";\n  /**\n   * Rules used to convert an XML document into its canonical form.\n   */\n  canonicalizationAlgorithm: CanonicalizationAlgorithmType =\n    \"http://www.w3.org/2001/10/xml-exc-c14n#\";\n  /**\n   * It specifies a list of namespace prefixes that should be considered \"inclusive\" during the canonicalization process.\n   */\n  inclusiveNamespacesPrefixList: string[] = [];\n  namespaceResolver: XPathNSResolver = {\n    lookupNamespaceURI: function (/* prefix */) {\n      throw new Error(\"Not implemented\");\n    },\n  };\n  implicitTransforms: ReadonlyArray<CanonicalizationOrTransformAlgorithmType> = [];\n  keyInfoAttributes: { [attrName: string]: string } = {};\n  getKeyInfoContent = SignedXml.getKeyInfoContent;\n  getCertFromKeyInfo = SignedXml.getCertFromKeyInfo;\n\n  // Internal state\n  /**\n   * Specifies the data to be signed within an XML document. See {@link Reference}\n   */\n  private references: Reference[] = [];\n  private id = 0;\n  private signedXml = \"\";\n  private signatureXml = \"\";\n  private signatureNode: Node | null = null;\n  private signatureValue = \"\";\n  private originalXmlWithIds = \"\";\n  /**\n   * Contains validation errors (if any) after {@link checkSignature} method is called\n   */\n  validationErrors: string[] = [];\n  private keyInfo: Node | null = null;\n\n  /**\n   *  To add a new transformation algorithm create a new class that implements the {@link TransformationAlgorithm} interface, and register it here. More info: {@link https://github.com/node-saml/xml-crypto#customizing-algorithms|Customizing Algorithms}\n   */\n  CanonicalizationAlgorithms: Record<\n    CanonicalizationOrTransformAlgorithmType,\n    new () => CanonicalizationOrTransformationAlgorithm\n  > = {\n    \"http://www.w3.org/TR/2001/REC-xml-c14n-20010315\": c14n.C14nCanonicalization,\n    \"http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments\":\n      c14n.C14nCanonicalizationWithComments,\n    \"http://www.w3.org/2001/10/xml-exc-c14n#\": execC14n.ExclusiveCanonicalization,\n    \"http://www.w3.org/2001/10/xml-exc-c14n#WithComments\":\n      execC14n.ExclusiveCanonicalizationWithComments,\n    \"http://www.w3.org/2000/09/xmldsig#enveloped-signature\": envelopedSignatures.EnvelopedSignature,\n  };\n\n  /**\n   * To add a new hash algorithm create a new class that implements the {@link HashAlgorithm} interface, and register it here. More info: {@link https://github.com/node-saml/xml-crypto#customizing-algorithms|Customizing Algorithms}\n   */\n  HashAlgorithms: Record<HashAlgorithmType, new () => HashAlgorithm> = {\n    \"http://www.w3.org/2000/09/xmldsig#sha1\": hashAlgorithms.Sha1,\n    \"http://www.w3.org/2001/04/xmlenc#sha256\": hashAlgorithms.Sha256,\n    \"http://www.w3.org/2001/04/xmlenc#sha512\": hashAlgorithms.Sha512,\n  };\n\n  /**\n   * To add a new signature algorithm create a new class that implements the {@link SignatureAlgorithm} interface, and register it here. More info: {@link https://github.com/node-saml/xml-crypto#customizing-algorithms|Customizing Algorithms}\n   */\n  SignatureAlgorithms: Record<SignatureAlgorithmType, new () => SignatureAlgorithm> = {\n    \"http://www.w3.org/2000/09/xmldsig#rsa-sha1\": signatureAlgorithms.RsaSha1,\n    \"http://www.w3.org/2001/04/xmldsig-more#rsa-sha256\": signatureAlgorithms.RsaSha256,\n    \"http://www.w3.org/2001/04/xmldsig-more#rsa-sha512\": signatureAlgorithms.RsaSha512,\n    // Disabled by default due to key confusion concerns.\n    // 'http://www.w3.org/2000/09/xmldsig#hmac-sha1': SignatureAlgorithms.HmacSha1\n  };\n\n  static defaultNsForPrefix = {\n    ds: \"http://www.w3.org/2000/09/xmldsig#\",\n  };\n\n  /**\n   * The SignedXml constructor provides an abstraction for sign and verify xml documents. The object is constructed using\n   * @param options {@link SignedXmlOptions}\n   */\n  constructor(options: SignedXmlOptions = {}) {\n    const {\n      idMode,\n      idAttribute,\n      privateKey,\n      publicCert,\n      signatureAlgorithm,\n      canonicalizationAlgorithm,\n      inclusiveNamespacesPrefixList,\n      implicitTransforms,\n      keyInfoAttributes,\n      getKeyInfoContent,\n      getCertFromKeyInfo,\n    } = options;\n\n    // Options\n    this.idMode = idMode;\n    this.idAttributes = [\"Id\", \"ID\", \"id\"];\n    if (idAttribute) {\n      this.idAttributes.unshift(idAttribute);\n    }\n    this.privateKey = privateKey;\n    this.publicCert = publicCert;\n    this.signatureAlgorithm = signatureAlgorithm ?? this.signatureAlgorithm;\n    this.canonicalizationAlgorithm = canonicalizationAlgorithm ?? this.canonicalizationAlgorithm;\n    if (typeof inclusiveNamespacesPrefixList === \"string\") {\n      this.inclusiveNamespacesPrefixList = inclusiveNamespacesPrefixList.split(\" \");\n    } else if (utils.isArrayHasLength(inclusiveNamespacesPrefixList)) {\n      this.inclusiveNamespacesPrefixList = inclusiveNamespacesPrefixList;\n    }\n    this.implicitTransforms = implicitTransforms ?? this.implicitTransforms;\n    this.keyInfoAttributes = keyInfoAttributes ?? this.keyInfoAttributes;\n    this.getKeyInfoContent = getKeyInfoContent ?? this.getKeyInfoContent;\n    this.getCertFromKeyInfo = getCertFromKeyInfo ?? this.getCertFromKeyInfo;\n    this.CanonicalizationAlgorithms;\n    this.HashAlgorithms;\n    this.SignatureAlgorithms;\n  }\n\n  /**\n   * Due to key-confusion issues, it's risky to have both hmac\n   * and digital signature algorithms enabled at the same time.\n   * This enables HMAC and disables other signing algorithms.\n   */\n  enableHMAC(): void {\n    this.SignatureAlgorithms = {\n      \"http://www.w3.org/2000/09/xmldsig#hmac-sha1\": signatureAlgorithms.HmacSha1,\n    };\n    this.getKeyInfoContent = () => null;\n  }\n\n  /**\n   * Builds the contents of a KeyInfo element as an XML string.\n   *\n   * For example, if the value of the prefix argument is 'foo', then\n   * the resultant XML string will be \"<foo:X509Data></foo:X509Data>\"\n   *\n   * @return an XML string representation of the contents of a KeyInfo element, or `null` if no `KeyInfo` element should be included\n   */\n  static getKeyInfoContent({ publicCert, prefix }: GetKeyInfoContentArgs): string | null {\n    if (publicCert == null) {\n      return null;\n    }\n\n    prefix = prefix ? `${prefix}:` : \"\";\n\n    let x509Certs = \"\";\n    if (Buffer.isBuffer(publicCert)) {\n      publicCert = publicCert.toString(\"latin1\");\n    }\n\n    let publicCertMatches: string[] = [];\n    if (typeof publicCert === \"string\") {\n      publicCertMatches = publicCert.match(utils.EXTRACT_X509_CERTS) || [];\n    }\n\n    if (publicCertMatches.length > 0) {\n      x509Certs = publicCertMatches\n        .map((c) => `<X509Certificate>${utils.pemToDer(c).toString(\"base64\")}</X509Certificate>`)\n        .join(\"\");\n    }\n\n    return `<${prefix}X509Data>${x509Certs}</${prefix}X509Data>`;\n  }\n\n  /**\n   * Returns the value of the signing certificate based on the contents of the\n   * specified KeyInfo.\n   *\n   * @param keyInfo KeyInfo element (see https://www.w3.org/TR/2008/REC-xmldsig-core-20080610/#sec-X509Data)\n   * @return the signing certificate as a string in PEM format\n   */\n  static getCertFromKeyInfo(keyInfo?: Node | null): string | null {\n    if (keyInfo != null) {\n      const certs = xpath.select1(\".//*[local-name(.)='X509Certificate']\", keyInfo);\n      if (xpath.isNodeLike(certs)) {\n        return utils.derToPem(certs.textContent || \"\", \"CERTIFICATE\");\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Validates the signature of the provided XML document synchronously using the configured key info provider.\n   *\n   * @param xml The XML document containing the signature to be validated.\n   * @returns `true` if the signature is valid\n   * @throws Error if no key info resolver is provided.\n   */\n  checkSignature(xml: string): boolean;\n  /**\n   * Validates the signature of the provided XML document synchronously using the configured key info provider.\n   *\n   * @param xml The XML document containing the signature to be validated.\n   * @param callback Callback function to handle the validation result asynchronously.\n   * @throws Error if the last parameter is provided and is not a function, or if no key info resolver is provided.\n   */\n  checkSignature(xml: string, callback: (error: Error | null, isValid?: boolean) => void): void;\n  checkSignature(\n    xml: string,\n    callback?: (error: Error | null, isValid?: boolean) => void,\n  ): unknown {\n    if (callback != null && typeof callback !== \"function\") {\n      throw new Error(\"Last parameter must be a callback function\");\n    }\n\n    this.validationErrors = [];\n    this.signedXml = xml;\n\n    const doc = new xmldom.DOMParser().parseFromString(xml);\n\n    if (!this.validateReferences(doc)) {\n      if (!callback) {\n        return false;\n      } else {\n        callback(new Error(\"Could not validate references\"));\n        return;\n      }\n    }\n\n    if (!callback) {\n      // Synchronous flow\n      if (!this.validateSignatureValue(doc)) {\n        return false;\n      }\n      return true;\n    } else {\n      // Asynchronous flow\n      this.validateSignatureValue(doc, (err: Error | null, isValidSignature?: boolean) => {\n        if (err) {\n          this.validationErrors.push(\n            `invalid signature: the signature value ${this.signatureValue} is incorrect`,\n          );\n          callback(err);\n        } else {\n          callback(null, isValidSignature);\n        }\n      });\n    }\n  }\n\n  getCanonSignedInfoXml(doc: Document) {\n    if (this.signatureNode == null) {\n      throw new Error(\"No signature found.\");\n    }\n\n    const signedInfo = utils.findChildren(this.signatureNode, \"SignedInfo\");\n    if (signedInfo.length === 0) {\n      throw new Error(\"could not find SignedInfo element in the message\");\n    }\n\n    if (\n      this.canonicalizationAlgorithm === \"http://www.w3.org/TR/2001/REC-xml-c14n-20010315\" ||\n      this.canonicalizationAlgorithm ===\n        \"http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments\"\n    ) {\n      if (!doc || typeof doc !== \"object\") {\n        throw new Error(\n          \"When canonicalization method is non-exclusive, whole xml dom must be provided as an argument\",\n        );\n      }\n    }\n\n    /**\n     * Search for ancestor namespaces before canonicalization.\n     */\n    const ancestorNamespaces = utils.findAncestorNs(doc, \"//*[local-name()='SignedInfo']\");\n\n    const c14nOptions = {\n      ancestorNamespaces: ancestorNamespaces,\n    };\n    return this.getCanonXml([this.canonicalizationAlgorithm], signedInfo[0], c14nOptions);\n  }\n\n  getCanonReferenceXml(doc, ref, node) {\n    /**\n     * Search for ancestor namespaces before canonicalization.\n     */\n    if (Array.isArray(ref.transforms)) {\n      ref.ancestorNamespaces = utils.findAncestorNs(doc, ref.xpath, this.namespaceResolver);\n    }\n\n    const c14nOptions = {\n      inclusiveNamespacesPrefixList: ref.inclusiveNamespacesPrefixList,\n      ancestorNamespaces: ref.ancestorNamespaces,\n    };\n\n    return this.getCanonXml(ref.transforms, node, c14nOptions);\n  }\n\n  validateSignatureValue(doc: Document): boolean;\n  validateSignatureValue(doc: Document, callback: ErrorFirstCallback<boolean>): void;\n  validateSignatureValue(doc: Document, callback?: ErrorFirstCallback<boolean>): boolean | void {\n    const signedInfoCanon = this.getCanonSignedInfoXml(doc);\n    const signer = this.findSignatureAlgorithm(this.signatureAlgorithm);\n    const key = this.getCertFromKeyInfo(this.keyInfo) || this.publicCert || this.privateKey;\n    if (key == null) {\n      throw new Error(\"KeyInfo or publicCert or privateKey is required to validate signature\");\n    }\n    if (typeof callback === \"function\") {\n      signer.verifySignature(signedInfoCanon, key, this.signatureValue, callback);\n    } else {\n      const res = signer.verifySignature(signedInfoCanon, key, this.signatureValue);\n      if (res === false) {\n        this.validationErrors.push(\n          `invalid signature: the signature value ${this.signatureValue} is incorrect`,\n        );\n      }\n      return res;\n    }\n  }\n\n  calculateSignatureValue(doc: Document, callback?: ErrorFirstCallback<string>) {\n    const signedInfoCanon = this.getCanonSignedInfoXml(doc);\n    const signer = this.findSignatureAlgorithm(this.signatureAlgorithm);\n    if (this.privateKey == null) {\n      throw new Error(\"Private key is required to compute signature\");\n    }\n    if (typeof callback === \"function\") {\n      signer.getSignature(signedInfoCanon, this.privateKey, callback);\n    } else {\n      this.signatureValue = signer.getSignature(signedInfoCanon, this.privateKey);\n    }\n  }\n\n  findSignatureAlgorithm(name: SignatureAlgorithmType) {\n    const algo = this.SignatureAlgorithms[name];\n    if (algo) {\n      return new algo();\n    } else {\n      throw new Error(`signature algorithm '${name}' is not supported`);\n    }\n  }\n\n  findCanonicalizationAlgorithm(name: CanonicalizationOrTransformAlgorithmType) {\n    const algo = this.CanonicalizationAlgorithms[name];\n    if (algo) {\n      return new algo();\n    } else {\n      throw new Error(`canonicalization algorithm '${name}' is not supported`);\n    }\n  }\n\n  findHashAlgorithm(name: HashAlgorithmType) {\n    const algo = this.HashAlgorithms[name];\n    if (algo) {\n      return new algo();\n    } else {\n      throw new Error(`hash algorithm '${name}' is not supported`);\n    }\n  }\n\n  validateReferences(doc) {\n    for (const ref of this.references) {\n      let elemXpath;\n      const uri = ref.uri?.[0] === \"#\" ? ref.uri.substring(1) : ref.uri;\n      let elem: xpath.SelectReturnType = [];\n\n      if (uri === \"\") {\n        elem = xpath.select(\"//*\", doc);\n      } else if (uri?.indexOf(\"'\") !== -1) {\n        // xpath injection\n        throw new Error(\"Cannot validate a uri with quotes inside it\");\n      } else {\n        let num_elements_for_id = 0;\n        for (const attr of this.idAttributes) {\n          const tmp_elemXpath = `//*[@*[local-name(.)='${attr}']='${uri}']`;\n          const tmp_elem = xpath.select(tmp_elemXpath, doc);\n          if (utils.isArrayHasLength(tmp_elem)) {\n            num_elements_for_id += tmp_elem.length;\n            elem = tmp_elem;\n            elemXpath = tmp_elemXpath;\n          }\n        }\n        if (num_elements_for_id > 1) {\n          throw new Error(\n            \"Cannot validate a document which contains multiple elements with the \" +\n              \"same value for the ID / Id / Id attributes, in order to prevent \" +\n              \"signature wrapping attack.\",\n          );\n        }\n\n        ref.xpath = elemXpath;\n      }\n\n      // Note, we are using the last found element from the loop above\n      if (!utils.isArrayHasLength(elem)) {\n        this.validationErrors.push(\n          `invalid signature: the signature references an element with uri ${ref.uri} but could not find such element in the xml`,\n        );\n        return false;\n      }\n\n      const canonXml = this.getCanonReferenceXml(doc, ref, elem[0]);\n\n      const hash = this.findHashAlgorithm(ref.digestAlgorithm);\n      const digest = hash.getHash(canonXml);\n\n      if (!utils.validateDigestValue(digest, ref.digestValue)) {\n        this.validationErrors.push(\n          `invalid signature: for uri ${ref.uri} calculated digest is ${digest} but the xml to validate supplies digest ${ref.digestValue}`,\n        );\n\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Loads the signature information from the provided XML node or string.\n   *\n   * @param signatureNode The XML node or string representing the signature.\n   */\n  loadSignature(signatureNode: Node | string): void {\n    if (typeof signatureNode === \"string\") {\n      this.signatureNode = signatureNode = new xmldom.DOMParser().parseFromString(signatureNode);\n    } else {\n      this.signatureNode = signatureNode;\n    }\n\n    this.signatureXml = signatureNode.toString();\n\n    const nodes = xpath.select(\n      \".//*[local-name(.)='CanonicalizationMethod']/@Algorithm\",\n      signatureNode,\n    );\n    if (!utils.isArrayHasLength(nodes)) {\n      throw new Error(\"could not find CanonicalizationMethod/@Algorithm element\");\n    }\n\n    if (xpath.isAttribute(nodes[0])) {\n      this.canonicalizationAlgorithm = nodes[0].value as CanonicalizationAlgorithmType;\n    }\n\n    const signatureAlgorithm = xpath.select1(\n      \".//*[local-name(.)='SignatureMethod']/@Algorithm\",\n      signatureNode,\n    );\n\n    if (xpath.isAttribute(signatureAlgorithm)) {\n      this.signatureAlgorithm = signatureAlgorithm.value as SignatureAlgorithmType;\n    }\n\n    this.references = [];\n    const references = xpath.select(\n      \".//*[local-name(.)='SignedInfo']/*[local-name(.)='Reference']\",\n      signatureNode,\n    );\n    if (!utils.isArrayHasLength(references)) {\n      throw new Error(\"could not find any Reference elements\");\n    }\n\n    for (const reference of references) {\n      this.loadReference(reference);\n    }\n\n    const signatureValue = xpath.select1(\n      \".//*[local-name(.)='SignatureValue']/text()\",\n      signatureNode,\n    );\n\n    if (xpath.isTextNode(signatureValue)) {\n      this.signatureValue = signatureValue.data.replace(/\\r?\\n/g, \"\");\n    }\n\n    const keyInfo = xpath.select1(\".//*[local-name(.)='KeyInfo']\", signatureNode);\n\n    // TODO: should this just be a single return instead of an array that we always take the first entry of?\n    if (xpath.isNodeLike(keyInfo)) {\n      this.keyInfo = keyInfo;\n    }\n  }\n\n  /**\n   * Load the reference xml node to a model\n   *\n   */\n  loadReference(ref) {\n    let nodes = utils.findChildren(ref, \"DigestMethod\");\n    if (nodes.length === 0) {\n      throw new Error(`could not find DigestMethod in reference ${ref.toString()}`);\n    }\n    const digestAlgoNode = nodes[0];\n\n    const attr = utils.findAttr(digestAlgoNode, \"Algorithm\");\n    if (!attr) {\n      throw new Error(`could not find Algorithm attribute in node ${digestAlgoNode.toString()}`);\n    }\n    const digestAlgo = attr.value;\n\n    nodes = utils.findChildren(ref, \"DigestValue\");\n    if (nodes.length === 0) {\n      throw new Error(`could not find DigestValue node in reference ${ref.toString()}`);\n    }\n    const firstChild = nodes[0].firstChild;\n    if (!firstChild || !(\"data\" in firstChild)) {\n      throw new Error(`could not find the value of DigestValue in ${nodes[0].toString()}`);\n    }\n    const digestValue = firstChild.data;\n\n    const transforms: string[] = [];\n    let inclusiveNamespacesPrefixList: string[] = [];\n    nodes = utils.findChildren(ref, \"Transforms\");\n    if (nodes.length !== 0) {\n      const transformsNode = nodes[0];\n      const transformsAll = utils.findChildren(transformsNode, \"Transform\");\n      for (const transform of transformsAll) {\n        const transformAttr = utils.findAttr(transform, \"Algorithm\");\n\n        if (transformAttr) {\n          transforms.push(transformAttr.value);\n        }\n      }\n\n      // This is a little strange, we are looking for children of the last child of `transformsNode`\n      const inclusiveNamespaces = utils.findChildren(\n        transformsAll[transformsAll.length - 1],\n        \"InclusiveNamespaces\",\n      );\n      if (utils.isArrayHasLength(inclusiveNamespaces)) {\n        // Should really only be one prefix list, but maybe there's some circumstances where more than one to let's handle it\n        inclusiveNamespacesPrefixList = inclusiveNamespaces\n          .flatMap((namespace) => (namespace.getAttribute(\"PrefixList\") ?? \"\").split(\" \"))\n          .filter((value) => value.length > 0);\n      }\n\n      if (utils.isArrayHasLength(this.implicitTransforms)) {\n        this.implicitTransforms.forEach(function (t) {\n          transforms.push(t);\n        });\n      }\n\n      /**\n       * DigestMethods take an octet stream rather than a node set. If the output of the last transform is a node set, we\n       * need to canonicalize the node set to an octet stream using non-exclusive canonicalization. If there are no\n       * transforms, we need to canonicalize because URI dereferencing for a same-document reference will return a node-set.\n       * See:\n       * https://www.w3.org/TR/xmldsig-core1/#sec-DigestMethod\n       * https://www.w3.org/TR/xmldsig-core1/#sec-ReferenceProcessingModel\n       * https://www.w3.org/TR/xmldsig-core1/#sec-Same-Document\n       */\n      if (\n        transforms.length === 0 ||\n        transforms[transforms.length - 1] ===\n          \"http://www.w3.org/2000/09/xmldsig#enveloped-signature\"\n      ) {\n        transforms.push(\"http://www.w3.org/TR/2001/REC-xml-c14n-20010315\");\n      }\n\n      this.addReference({\n        transforms,\n        digestAlgorithm: digestAlgo,\n        uri: utils.findAttr(ref, \"URI\")?.value,\n        digestValue,\n        inclusiveNamespacesPrefixList,\n        isEmptyUri: false,\n      });\n    }\n  }\n\n  /**\n   * Adds a reference to the signature.\n   *\n   * @param xpath The XPath expression to select the XML nodes to be referenced.\n   * @param transforms An array of transform algorithms to be applied to the selected nodes. Defaults to [\"http://www.w3.org/2001/10/xml-exc-c14n#\"].\n   * @param digestAlgorithm The digest algorithm to use for computing the digest value. Defaults to \"http://www.w3.org/2000/09/xmldsig#sha1\".\n   * @param uri The URI identifier for the reference. If empty, an empty URI will be used.\n   * @param digestValue The expected digest value for the reference.\n   * @param inclusiveNamespacesPrefixList The prefix list for inclusive namespace canonicalization.\n   * @param isEmptyUri Indicates whether the URI is empty. Defaults to `false`.\n   */\n  addReference({\n    xpath,\n    transforms = [\"http://www.w3.org/2001/10/xml-exc-c14n#\"],\n    digestAlgorithm = \"http://www.w3.org/2000/09/xmldsig#sha1\",\n    uri = \"\",\n    digestValue,\n    inclusiveNamespacesPrefixList = [],\n    isEmptyUri = false,\n  }: Partial<Reference> & Pick<Reference, \"xpath\">): void {\n    this.references.push({\n      xpath,\n      transforms,\n      digestAlgorithm,\n      uri,\n      digestValue,\n      inclusiveNamespacesPrefixList,\n      isEmptyUri,\n    });\n  }\n\n  /**\n   * Compute the signature of the given XML (using the already defined settings).\n   *\n   * @param xml The XML to compute the signature for.\n   * @param callback A callback function to handle the signature computation asynchronously.\n   * @returns void\n   * @throws TypeError If the xml can not be parsed.\n   */\n  computeSignature(xml: string): void;\n\n  /**\n   * Compute the signature of the given XML (using the already defined settings).\n   *\n   * @param xml The XML to compute the signature for.\n   * @param callback A callback function to handle the signature computation asynchronously.\n   * @returns void\n   * @throws TypeError If the xml can not be parsed.\n   */\n  computeSignature(xml: string, callback: ErrorFirstCallback<SignedXml>): void;\n\n  /**\n   * Compute the signature of the given XML (using the already defined settings).\n   *\n   * @param xml The XML to compute the signature for.\n   * @param opts An object containing options for the signature computation.\n   * @returns If no callback is provided, returns `this` (the instance of SignedXml).\n   * @throws TypeError If the xml can not be parsed, or Error if there were invalid options passed.\n   */\n  computeSignature(xml: string, options: ComputeSignatureOptions): void;\n\n  /**\n   * Compute the signature of the given XML (using the already defined settings).\n   *\n   * @param xml The XML to compute the signature for.\n   * @param opts An object containing options for the signature computation.\n   * @param callback A callback function to handle the signature computation asynchronously.\n   * @returns void\n   * @throws TypeError If the xml can not be parsed, or Error if there were invalid options passed.\n   */\n  computeSignature(\n    xml: string,\n    options: ComputeSignatureOptions,\n    callback: ErrorFirstCallback<SignedXml>,\n  ): void;\n\n  computeSignature(\n    xml: string,\n    options?: ComputeSignatureOptions | ErrorFirstCallback<SignedXml>,\n    callbackParam?: ErrorFirstCallback<SignedXml>,\n  ): void {\n    let callback: ErrorFirstCallback<SignedXml>;\n    if (typeof options === \"function\" && callbackParam == null) {\n      callback = options as ErrorFirstCallback<SignedXml>;\n      options = {} as ComputeSignatureOptions;\n    } else {\n      callback = callbackParam as ErrorFirstCallback<SignedXml>;\n      options = (options ?? {}) as ComputeSignatureOptions;\n    }\n\n    const doc = new xmldom.DOMParser().parseFromString(xml);\n    let xmlNsAttr = \"xmlns\";\n    const signatureAttrs: string[] = [];\n    let currentPrefix: string;\n\n    const validActions = [\"append\", \"prepend\", \"before\", \"after\"];\n\n    const prefix = options.prefix;\n    const attrs = options.attrs || {};\n    const location = options.location || {};\n    const existingPrefixes = options.existingPrefixes || {};\n\n    this.namespaceResolver = {\n      lookupNamespaceURI: function (prefix) {\n        return prefix ? existingPrefixes[prefix] : null;\n      },\n    };\n\n    // defaults to the root node\n    location.reference = location.reference || \"/*\";\n    // defaults to append action\n    location.action = location.action || \"append\";\n\n    if (validActions.indexOf(location.action) === -1) {\n      const err = new Error(\n        `location.action option has an invalid action: ${\n          location.action\n        }, must be any of the following values: ${validActions.join(\", \")}`,\n      );\n      if (!callback) {\n        throw err;\n      } else {\n        callback(err);\n        return;\n      }\n    }\n\n    // automatic insertion of `:`\n    if (prefix) {\n      xmlNsAttr += `:${prefix}`;\n      currentPrefix = `${prefix}:`;\n    } else {\n      currentPrefix = \"\";\n    }\n\n    Object.keys(attrs).forEach(function (name) {\n      if (name !== \"xmlns\" && name !== xmlNsAttr) {\n        signatureAttrs.push(`${name}=\"${attrs[name]}\"`);\n      }\n    });\n\n    // add the xml namespace attribute\n    signatureAttrs.push(`${xmlNsAttr}=\"http://www.w3.org/2000/09/xmldsig#\"`);\n\n    let signatureXml = `<${currentPrefix}Signature ${signatureAttrs.join(\" \")}>`;\n\n    signatureXml += this.createSignedInfo(doc, prefix);\n    signatureXml += this.getKeyInfo(prefix);\n    signatureXml += `</${currentPrefix}Signature>`;\n\n    this.originalXmlWithIds = doc.toString();\n\n    let existingPrefixesString = \"\";\n    Object.keys(existingPrefixes).forEach(function (key) {\n      existingPrefixesString += `xmlns:${key}=\"${existingPrefixes[key]}\" `;\n    });\n\n    // A trick to remove the namespaces that already exist in the xml\n    // This only works if the prefix and namespace match with those in the xml\n    const dummySignatureWrapper = `<Dummy ${existingPrefixesString}>${signatureXml}</Dummy>`;\n    const nodeXml = new xmldom.DOMParser().parseFromString(dummySignatureWrapper);\n\n    // Because we are using a dummy wrapper hack described above, we know there will be a `firstChild`\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const signatureDoc = nodeXml.documentElement.firstChild!;\n\n    const referenceNode = xpath.select1(location.reference, doc);\n\n    if (!xpath.isNodeLike(referenceNode)) {\n      const err2 = new Error(\n        `the following xpath cannot be used because it was not found: ${location.reference}`,\n      );\n      if (!callback) {\n        throw err2;\n      } else {\n        callback(err2);\n        return;\n      }\n    }\n\n    if (location.action === \"append\") {\n      referenceNode.appendChild(signatureDoc);\n    } else if (location.action === \"prepend\") {\n      referenceNode.insertBefore(signatureDoc, referenceNode.firstChild);\n    } else if (location.action === \"before\") {\n      if (referenceNode.parentNode == null) {\n        throw new Error(\n          \"`location.reference` refers to the root node (by default), so we can't insert `before`\",\n        );\n      }\n      referenceNode.parentNode.insertBefore(signatureDoc, referenceNode);\n    } else if (location.action === \"after\") {\n      if (referenceNode.parentNode == null) {\n        throw new Error(\n          \"`location.reference` refers to the root node (by default), so we can't insert `after`\",\n        );\n      }\n      referenceNode.parentNode.insertBefore(signatureDoc, referenceNode.nextSibling);\n    }\n\n    this.signatureNode = signatureDoc;\n    const signedInfoNodes = utils.findChildren(this.signatureNode, \"SignedInfo\");\n    if (signedInfoNodes.length === 0) {\n      const err3 = new Error(\"could not find SignedInfo element in the message\");\n      if (!callback) {\n        throw err3;\n      } else {\n        callback(err3);\n        return;\n      }\n    }\n    const signedInfoNode = signedInfoNodes[0];\n\n    if (typeof callback === \"function\") {\n      // Asynchronous flow\n      this.calculateSignatureValue(doc, (err, signature) => {\n        if (err) {\n          callback(err);\n        } else {\n          this.signatureValue = signature || \"\";\n          signatureDoc.insertBefore(this.createSignature(prefix), signedInfoNode.nextSibling);\n          this.signatureXml = signatureDoc.toString();\n          this.signedXml = doc.toString();\n          callback(null, this);\n        }\n      });\n    } else {\n      // Synchronous flow\n      this.calculateSignatureValue(doc);\n      signatureDoc.insertBefore(this.createSignature(prefix), signedInfoNode.nextSibling);\n      this.signatureXml = signatureDoc.toString();\n      this.signedXml = doc.toString();\n    }\n  }\n\n  getKeyInfo(prefix) {\n    const currentPrefix = prefix ? `${prefix}:` : \"\";\n\n    let keyInfoAttrs = \"\";\n    if (this.keyInfoAttributes) {\n      Object.keys(this.keyInfoAttributes).forEach((name) => {\n        keyInfoAttrs += ` ${name}=\"${this.keyInfoAttributes[name]}\"`;\n      });\n    }\n\n    const keyInfoContent = this.getKeyInfoContent({ publicCert: this.publicCert, prefix });\n    if (keyInfoAttrs || keyInfoContent) {\n      return `<${currentPrefix}KeyInfo${keyInfoAttrs}>${keyInfoContent}</${currentPrefix}KeyInfo>`;\n    }\n\n    return \"\";\n  }\n\n  /**\n   * Generate the Reference nodes (as part of the signature process)\n   *\n   */\n  createReferences(doc, prefix) {\n    let res = \"\";\n\n    prefix = prefix || \"\";\n    prefix = prefix ? `${prefix}:` : prefix;\n\n    for (const ref of this.references) {\n      const nodes = xpath.selectWithResolver(ref.xpath ?? \"\", doc, this.namespaceResolver);\n\n      if (!utils.isArrayHasLength(nodes)) {\n        throw new Error(\n          `the following xpath cannot be signed because it was not found: ${ref.xpath}`,\n        );\n      }\n\n      for (const node of nodes) {\n        if (ref.isEmptyUri) {\n          res += `<${prefix}Reference URI=\"\">`;\n        } else {\n          const id = this.ensureHasId(node);\n          ref.uri = id;\n          res += `<${prefix}Reference URI=\"#${id}\">`;\n        }\n        res += `<${prefix}Transforms>`;\n        for (const trans of ref.transforms || []) {\n          const transform = this.findCanonicalizationAlgorithm(trans);\n          res += `<${prefix}Transform Algorithm=\"${transform.getAlgorithmName()}\"`;\n          if (utils.isArrayHasLength(ref.inclusiveNamespacesPrefixList)) {\n            res += \">\";\n            res += `<InclusiveNamespaces PrefixList=\"${ref.inclusiveNamespacesPrefixList.join(\n              \" \",\n            )}\" xmlns=\"${transform.getAlgorithmName()}\"/>`;\n            res += `</${prefix}Transform>`;\n          } else {\n            res += \" />\";\n          }\n        }\n\n        const canonXml = this.getCanonReferenceXml(doc, ref, node);\n\n        const digestAlgorithm = this.findHashAlgorithm(ref.digestAlgorithm);\n        res +=\n          `</${prefix}Transforms>` +\n          `<${prefix}DigestMethod Algorithm=\"${digestAlgorithm.getAlgorithmName()}\" />` +\n          `<${prefix}DigestValue>${digestAlgorithm.getHash(canonXml)}</${prefix}DigestValue>` +\n          `</${prefix}Reference>`;\n      }\n    }\n\n    return res;\n  }\n\n  getCanonXml(\n    transforms: CanonicalizationAlgorithmType[],\n    node,\n    options: CanonicalizationOrTransformationAlgorithmProcessOptions,\n  ) {\n    options = options || {};\n    options.defaultNsForPrefix = options.defaultNsForPrefix ?? SignedXml.defaultNsForPrefix;\n    options.signatureNode = this.signatureNode;\n\n    let canonXml = node.cloneNode(true); // Deep clone\n\n    transforms.forEach((transformName) => {\n      const transform = this.findCanonicalizationAlgorithm(transformName);\n      canonXml = transform.process(canonXml, options);\n      //TODO: currently transform.process may return either Node or String value (enveloped transformation returns Node, exclusive-canonicalization returns String).\n      //This either needs to be more explicit in the API, or all should return the same.\n      //exclusive-canonicalization returns String since it builds the Xml by hand. If it had used xmldom it would incorrectly minimize empty tags\n      //to <x/> instead of <x></x> and also incorrectly handle some delicate line break issues.\n      //enveloped transformation returns Node since if it would return String consider this case:\n      //<x xmlns:p='ns'><p:y/></x>\n      //if only y is the node to sign then a string would be <p:y/> without the definition of the p namespace. probably xmldom toString() should have added it.\n    });\n\n    return canonXml.toString();\n  }\n\n  /**\n   * Ensure an element has Id attribute. If not create it with unique value.\n   * Work with both normal and wssecurity Id flavour\n   */\n  ensureHasId(node) {\n    let attr;\n\n    if (this.idMode === \"wssecurity\") {\n      attr = utils.findAttr(\n        node,\n        \"Id\",\n        \"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\",\n      );\n    } else {\n      this.idAttributes.some((idAttribute) => {\n        attr = utils.findAttr(node, idAttribute);\n        return !!attr; // This will break the loop as soon as a truthy attr is found.\n      });\n    }\n\n    if (attr) {\n      return attr.value;\n    }\n\n    //add the attribute\n    const id = `_${this.id++}`;\n\n    if (this.idMode === \"wssecurity\") {\n      node.setAttributeNS(\n        \"http://www.w3.org/2000/xmlns/\",\n        \"xmlns:wsu\",\n        \"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\",\n      );\n      node.setAttributeNS(\n        \"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\",\n        \"wsu:Id\",\n        id,\n      );\n    } else {\n      node.setAttribute(\"Id\", id);\n    }\n\n    return id;\n  }\n\n  /**\n   * Create the SignedInfo element\n   *\n   */\n  createSignedInfo(doc, prefix) {\n    const transform = this.findCanonicalizationAlgorithm(this.canonicalizationAlgorithm);\n    const algo = this.findSignatureAlgorithm(this.signatureAlgorithm);\n    let currentPrefix;\n\n    currentPrefix = prefix || \"\";\n    currentPrefix = currentPrefix ? `${currentPrefix}:` : currentPrefix;\n\n    let res = `<${currentPrefix}SignedInfo>`;\n    res += `<${currentPrefix}CanonicalizationMethod Algorithm=\"${transform.getAlgorithmName()}\"`;\n    if (utils.isArrayHasLength(this.inclusiveNamespacesPrefixList)) {\n      res += \">\";\n      res += `<InclusiveNamespaces PrefixList=\"${this.inclusiveNamespacesPrefixList.join(\n        \" \",\n      )}\" xmlns=\"${transform.getAlgorithmName()}\"/>`;\n      res += `</${currentPrefix}CanonicalizationMethod>`;\n    } else {\n      res += \" />\";\n    }\n    res += `<${currentPrefix}SignatureMethod Algorithm=\"${algo.getAlgorithmName()}\" />`;\n\n    res += this.createReferences(doc, prefix);\n    res += `</${currentPrefix}SignedInfo>`;\n    return res;\n  }\n\n  /**\n   * Create the Signature element\n   *\n   */\n  createSignature(prefix?: string) {\n    let xmlNsAttr = \"xmlns\";\n\n    if (prefix) {\n      xmlNsAttr += `:${prefix}`;\n      prefix += \":\";\n    } else {\n      prefix = \"\";\n    }\n\n    const signatureValueXml = `<${prefix}SignatureValue>${this.signatureValue}</${prefix}SignatureValue>`;\n    //the canonicalization requires to get a valid xml node.\n    //we need to wrap the info in a dummy signature since it contains the default namespace.\n    const dummySignatureWrapper = `<${prefix}Signature ${xmlNsAttr}=\"http://www.w3.org/2000/09/xmldsig#\">${signatureValueXml}</${prefix}Signature>`;\n\n    const doc = new xmldom.DOMParser().parseFromString(dummySignatureWrapper);\n\n    // Because we are using a dummy wrapper hack described above, we know there will be a `firstChild`\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return doc.documentElement.firstChild!;\n  }\n\n  /**\n   * Returns just the signature part, must be called only after {@link computeSignature}\n   *\n   * @returns The signature XML.\n   */\n  getSignatureXml(): string {\n    return this.signatureXml;\n  }\n\n  /**\n   * Returns the original xml with Id attributes added on relevant elements (required for validation), must be called only after {@link computeSignature}\n   *\n   * @returns The original XML with IDs.\n   */\n  getOriginalXmlWithIds(): string {\n    return this.originalXmlWithIds;\n  }\n\n  /**\n   * Returns the original xml document with the signature in it, must be called only after {@link computeSignature}\n   *\n   * @returns The signed XML.\n   */\n  getSignedXml(): string {\n    return this.signedXml;\n  }\n}\n"]}